//@Header This file contains merged content generated by the Merlin File Manager utility.
//@Header 
//@Header Generation Date: 2024-07-28 12:58:26
//@Header Total Files Merged: 18
//@Header 
//@Header Files included in this merge:
//@Header Goat.Utility.Merlin.Lib\FileManager.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\GitIgnoreStyleMatcher.cs
//@Header //@Header * Merlin\CustomFormatter.cs
//@Header //@Header * Merlin\MerlinOptions.cs
//@Header //@Header * Merlin\Program.cs
//@Header //@Header * Merlin\SelfRegistration.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\obj\Debug\net8.0\Goat.Utility.Merlin.Lib.AssemblyInfo.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\obj\Debug\net8.0\Goat.Utility.Merlin.Lib.GlobalUsings.g.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\obj\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\obj\Release\net8.0\Goat.Utility.Merlin.Lib.AssemblyInfo.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\obj\Release\net8.0\Goat.Utility.Merlin.Lib.GlobalUsings.g.cs
//@Header //@Header * Merlin\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
//@Header //@Header * Merlin\obj\Debug\net8.0\Merlin.AssemblyInfo.cs
//@Header //@Header * Merlin\obj\Debug\net8.0\Merlin.GlobalUsings.g.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\obj\Release\net8.0\win-x64\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\obj\Release\net8.0\win-x64\Goat.Utility.Merlin.Lib.AssemblyInfo.cs
//@Header //@Header * Goat.Utility.Merlin.Lib\obj\Release\net8.0\win-x64\Goat.Utility.Merlin.Lib.GlobalUsings.g.cs
//@Header 
//@Header Instructions:
//@Header 1. This file is a compilation of multiple source files.
//@Header 2. The merged format is known as the Merlin wIZzard format aka MIZ.The default file extension is .miz.
//@Header 3. Each section starts with a //@FileName comment indicating the original file path.
//@Header 4. To modify specific sections, locate the corresponding //@FileName comment.
//@Header 5. When extracting, use the Merlin utility with the 'extract' command to separate the files.
//@Header 6. For any changes, it's recommended to modify the original source files and re-run the merge process.
//@Header 
//@Header Note: This file is auto-generated. Manual changes may be overwritten in future merges.
//@Header 

//@FileName Goat.Utility.Merlin.Lib/FileManager.cs
using System.ComponentModel.DataAnnotations;
using Microsoft.Extensions.Logging;
using System.Text;
using System.Text.RegularExpressions;
using System.Linq;

namespace Goat.Utility.Merlin.Lib
{
    public class FileManager
    {
        private readonly ILogger _logger;

        public FileManager(ILogger logger)
        {
            _logger = logger;
        }

        public static List<string> GetFilesToMerge(string sourceDirectory, IEnumerable<string> patterns)
        {
            var includePatterns = new List<string>();
            var excludePatterns = new List<string>();

            foreach (var pattern in patterns)
            {
                if (pattern.StartsWith("!"))
                    excludePatterns.Add(pattern.Substring(1));
                else
                    includePatterns.Add(pattern);
            }

            return Directory
                    .GetFiles(sourceDirectory, "*.*", SearchOption.AllDirectories)
                    .Where(file => ShouldIncludeFile(sourceDirectory,file, includePatterns, excludePatterns))
                    .ToList();
        }

        private static bool ShouldIncludeFile(string sourceDirectory,string file, List<string> includePatterns, List<string> excludePatterns)
        {
            var segments = file.Split(new[] { @"\", @"/" }, StringSplitOptions.None);
            var currentDirectory = sourceDirectory.Split(new[] { @"\", @"/" }, StringSplitOptions.None);
            var fileName = string.Join(@"/", segments.Skip(currentDirectory.Length));
           

            return GitIgnoreStyleMatcher.ShouldIncludeFile(fileName, includePatterns, excludePatterns);
        }

        //private static bool MatchesPattern(string fileName, string pattern)
        //{
        //    var regex = "^" + Regex.Escape(pattern).Replace("\\*", ".*").Replace("\\?", ".") + "$";
        //    return Regex.IsMatch(fileName, regex);
        //}

        public async Task MergeFilesAsync(List<string> files, string outputFile, string encoding)
        {
            await using var writer = new StreamWriter(outputFile, false, Encoding.GetEncoding(encoding));

            await WriteFileHeader(writer, files);

            foreach (var file in files)
            {
                var relativePath = Path.GetRelativePath(Directory.GetCurrentDirectory(), file);
                var segments = relativePath.Split(new[] { @"\", @"/" }, StringSplitOptions.None);
                await writer.WriteLineAsync($"//@FileName {string.Join(@"/",segments)}");
                await writer.WriteLineAsync(await File.ReadAllTextAsync(file, Encoding.GetEncoding(encoding)));
                _logger.LogInformation($"Merged file: {relativePath}");
            }
        }

        private async Task WriteFileHeader(StreamWriter writer, List<string> files)
        {
            var filename = "prompt.txt";
            if (!File.Exists(filename))
            {
                filename = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, filename);
            }
            var prompt = await File.ReadAllTextAsync(filename);
            var headerContent = string.Format(prompt,
                DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
                files.Count,
                string.Join("\n//@Header * ", files.Select(f => Path.GetRelativePath(Directory.GetCurrentDirectory(), f)))
            );

            foreach (var line in headerContent.Split('\n'))
            {
                await writer.WriteLineAsync($"//@Header {line.TrimEnd()}");
            }
            await writer.WriteLineAsync();
        }

        public async Task ExtractFilesAsync(string inputFile, string outputDirectory, string encoding)
        {
            var currentFile = "";
            var fileContent = new List<string>();

            using var reader = new StreamReader(inputFile, Encoding.GetEncoding(encoding));
            string? line = null;

            while ((line = await reader.ReadLineAsync()) != null)
            {
                if (line.StartsWith("//@Header"))
                {
                    continue; // Ignore header lines
                }

                if (line.StartsWith("//@FileName"))
                {
                    if (currentFile != "")
                    {
                        await WriteExtractedFileAsync(currentFile, fileContent, outputDirectory, encoding);
                        fileContent.Clear();
                    }
                    currentFile = line.Substring(11).Trim();
                }
                else
                {
                    fileContent.Add(line);
                }
            }

            if (currentFile != "")
            {
                await WriteExtractedFileAsync(currentFile, fileContent, outputDirectory, encoding);
            }
        }

        private async Task WriteExtractedFileAsync(string filePath, List<string> content, string outputDirectory, string encoding)
        {
            var fullPath = Path.Combine(outputDirectory, filePath);
            var directory = Path.GetDirectoryName(fullPath);
            if (string.IsNullOrEmpty(directory))
                throw new InvalidOperationException("Invalid output directory");

            if (!Directory.Exists(directory))
                Directory.CreateDirectory(directory);

            await File.WriteAllLinesAsync(fullPath, content, Encoding.GetEncoding(encoding));
            _logger.LogInformation($"Extracted file: {fullPath}");
        }
    }
}


//@FileName Goat.Utility.Merlin.Lib/GitIgnoreStyleMatcher.cs
using System.Text.RegularExpressions;

namespace Goat.Utility.Merlin.Lib
{
    
    public class GitIgnoreStyleMatcher
    {
        public static bool ShouldIncludeFile(string file, List<string> includePatterns, List<string> excludePatterns)
        {
            var relativePath = file.Replace('\\', '/');
            //var fileName = relativePath;
            var fileName = Path.GetFileName(file);

            bool isIncluded = includePatterns.Count == 0 || includePatterns.Any(p => MatchesPattern(relativePath, fileName, p));
            bool isExcluded = excludePatterns.Any(p => MatchesPattern(relativePath, fileName, p));

            return isIncluded && !isExcluded;
        }

        private static bool MatchesPattern(string relativePath, string fileName, string pattern)
        {
            pattern = pattern.Replace('\\', '/').Trim();

            // Handle negation
            bool isNegation = pattern.StartsWith("!");
            if (isNegation)
            {
                pattern = pattern.Substring(1);
            }

            // Convert .gitignore pattern to regex
            string regex = ConvertGitIgnorePatternToRegex(pattern);

            // Match against full path and filename
            bool isMatch = Regex.IsMatch(relativePath, regex, RegexOptions.IgnoreCase) ||
                           Regex.IsMatch(fileName, regex, RegexOptions.IgnoreCase);

            return isNegation ? !isMatch : isMatch;
        }

        private static string ConvertGitIgnorePatternToRegex(string pattern)
        {
            string regex = "^";

            for (int i = 0; i < pattern.Length; i++)
            {
                char c = pattern[i];
                switch (c)
                {
                    case '*':
                        regex += i + 1 < pattern.Length && pattern[i + 1] == '*'
                            ? ".*"
                            : "[^/]*";
                        break;
                    case '?':
                        regex += "[^/]";
                        break;
                    case '.':
                    case '+':
                    case '$':
                    case '^':
                    case '{':
                    case '[':
                    case '(':
                    case ')':
                    case '|':
                    case '}':
                    case ']':
                        regex += "\\" + c;
                        break;
                    case '\\':
                        regex += "\\\\";
                        break;
                    case '/':
                        regex += "\\/";
                        break;
                    default:
                        regex += c;
                        break;
                }
            }

            return regex + "$";
        }
    }
}

//@FileName Merlin/CustomFormatter.cs
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Logging.Console;

namespace Merlin
{
    public class CustomFormatterOptions : ConsoleFormatterOptions
    {
        public CustomFormatterOptions()
        {
            TimestampFormat = "yyyy-MM-dd HH:mm:ss ";
            UseUtcTimestamp = false;
        }
    }

    public class CustomFormatter : ConsoleFormatter
    {
        public CustomFormatter() : base("CustomFormatter") { }

        public override void Write<TState>(in LogEntry<TState> logEntry, IExternalScopeProvider scopeProvider, TextWriter textWriter)
        {
            string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            string logLevel = logEntry.LogLevel.ToString();
            string category = logEntry.Category;
            int? eventId = logEntry.EventId.Id;
            string message = logEntry.Formatter(logEntry.State, logEntry.Exception);

            textWriter.Write($"\u001b[32m{logLevel}:\u001b[0m ");
            textWriter.WriteLine($"{category}[{eventId}]: {message}");
        }
    }
}

//@FileName Merlin/MerlinOptions.cs
using CommandLine;

namespace Merlin
{

    [Verb("register", HelpText = "Register the application in the system PATH")]
    public class RegisterOptions
    {
        [Option('u', "unregister", Required = false, HelpText = "Unregister the application from the system PATH")]
        public bool Unregister { get; set; }
    }

    [Verb("merge", HelpText = "Merge multiple files into a single file")]
    public class MergeOptions
    {
        [Option('s', "source", Required = true, HelpText = "Source directory containing the files to merge")]
        public required string SourceDirectory { get; set; }

        [Option('o', "output", Required = true, HelpText = "Output file path for the merged content")]
        public required string OutputFile { get; set; }

        [Option('p', "patterns", Required = false, HelpText = "File patterns to include/exclude (e.g. *.cs, !*Test.cs)")]
        public IEnumerable<string>? Patterns { get; set; }

        [Option('e', "encoding", Required = false, Default = "utf-8", HelpText = "Encoding to use for reading/writing files")]
        public string? Encoding { get; set; }
    }

    [Verb("extract", HelpText = "Extract content from a merged file into separate files")]
    public class ExtractOptions
    {
        [Option('i', "input", Required = true, HelpText = "Input file to extract")]
        public required string InputFile { get; set; }

        [Option('o', "output", Required = true, HelpText = "Output directory for extracted files")]
        public required string OutputDirectory { get; set; }

        [Option('e', "encoding", Required = false, Default = "utf-8", HelpText = "Encoding to use for reading/writing files")]
        public string? Encoding { get; set; }
    }
}

//@FileName Merlin/Program.cs
using CommandLine;
using Goat.Utility.Merlin.Lib;
using Merlin;
using Microsoft.Extensions.Logging;
using System.Text;

using var loggerFactory = LoggerFactory.Create(builder =>
{
    builder
        .AddFilter("Microsoft", LogLevel.Warning)
        .AddFilter("System", LogLevel.Warning)
        //.AddFilter("CSharpFileManagerUtility", LogLevel.Debug)
        .AddConsole(options =>
        {
            options.FormatterName = "CustomFormatter";
            
        })
        .AddConsoleFormatter<CustomFormatter, CustomFormatterOptions>();
});
var logger = loggerFactory.CreateLogger("CSharpFileManagerUtility");

// Point d'entrée principal
var  parserResult  = await Parser.Default.ParseArguments<MergeOptions, ExtractOptions,RegisterOptions>(args)
    .MapResult(
        (MergeOptions opts) => MergeFilesAsync(opts, logger),
        (ExtractOptions opts) => ExtractFilesAsync(opts, logger),
        (RegisterOptions opts) => RegisterApplication(opts),
        errs => Task.FromResult(-1));

return parserResult;



static Task<int> RegisterApplication(RegisterOptions opts)
{
    try
    {
        if (opts.Unregister)
        {
            SelfRegistration.UnregisterFromPath();
            Console.WriteLine("Application unregistered from PATH");
        }
        else
        {
            SelfRegistration.RegisterInPath();
            Console.WriteLine("Application registered in PATH");
        }
        return Task.FromResult(0);
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error during registration: {ex.Message}");
        return Task.FromResult(1);
    }
}


static async Task<int> MergeFilesAsync(MergeOptions opts,ILogger logger)
{
    var fileManager = new FileManager(logger);
    try
    {
        var files = FileManager.GetFilesToMerge(opts.SourceDirectory, opts.Patterns ?? []);
        
        var outputFile = opts.OutputFile;
        bool hasNoExtension = string.IsNullOrEmpty(Path.GetExtension(outputFile));
        if (hasNoExtension)
        {
            outputFile += ".miz";
        }

        await fileManager.MergeFilesAsync(files, outputFile, opts.Encoding ?? Encoding.UTF8.EncodingName);
        logger.LogInformation($"Merged {files.Count} files into {outputFile}");
        return 0;
    }
    catch (Exception ex)
    {
        logger.LogError($"An error occurred during the merge operation {ex.Message}");
        return 1;
    }
}

static async Task<int> ExtractFilesAsync(ExtractOptions opts,ILogger logger)
{
    var fileManager = new FileManager(logger);

    try
    {
        await fileManager.ExtractFilesAsync(opts.InputFile, opts.OutputDirectory, opts.Encoding ?? Encoding.UTF8.EncodingName);
        logger.LogInformation($"Extracted files from {opts.InputFile} to {opts.OutputDirectory}");
        return 0;
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "An error occurred during the extract operation");
        return 1;
    }
}

//@FileName Merlin/SelfRegistration.cs
using System.Runtime.InteropServices;

namespace Merlin
{


    public static class SelfRegistration
    {
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr SendMessageTimeout(
            IntPtr hWnd,
            uint Msg,
            UIntPtr wParam,
            string lParam,
            uint fuFlags,
            uint uTimeout,
            out UIntPtr lpdwResult
        );

        private const int HWND_BROADCAST = 0xffff;
        private const uint WM_SETTINGCHANGE = 0x001A;
        private const uint SMTO_ABORTIFHUNG = 0x0002;

        public static void RegisterInPath()
        {
            string path = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.User) ?? string.Empty;
            string appDir = AppDomain.CurrentDomain.BaseDirectory;

            if (!path.Contains(appDir))
            {
                path = path.TrimEnd(';') + ";" + appDir;
                Environment.SetEnvironmentVariable("PATH", path, EnvironmentVariableTarget.User);

                // Notify other processes of environment change
                UIntPtr result;
                SendMessageTimeout(
                    (IntPtr)HWND_BROADCAST,
                    WM_SETTINGCHANGE,
                    UIntPtr.Zero,
                    "Environment",
                    SMTO_ABORTIFHUNG,
                    5000,
                    out result
                );
            }
        }

        public static void UnregisterFromPath()
        {
            string path = Environment.GetEnvironmentVariable("PATH", EnvironmentVariableTarget.Machine) ?? string.Empty;
            string appDir = AppDomain.CurrentDomain.BaseDirectory;

            if (path.Contains(appDir))
            {
                path = path.Replace(appDir, "").Replace(";;", ";").TrimEnd(';');
                Environment.SetEnvironmentVariable("PATH", path, EnvironmentVariableTarget.Machine);

                // Notify other processes of environment change
                UIntPtr result;
                SendMessageTimeout(
                    (IntPtr)HWND_BROADCAST,
                    WM_SETTINGCHANGE,
                    UIntPtr.Zero,
                    "Environment",
                    SMTO_ABORTIFHUNG,
                    5000,
                    out result
                );
            }
        }
    }
}

//@FileName Goat.Utility.Merlin.Lib/obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

//@FileName Goat.Utility.Merlin.Lib/obj/Debug/net8.0/Goat.Utility.Merlin.Lib.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.42000
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Goat.Utility.Merlin.Lib")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+29cf67bda211c0ce028e46335796ba2a4da7d199")]
[assembly: System.Reflection.AssemblyProductAttribute("Goat.Utility.Merlin.Lib")]
[assembly: System.Reflection.AssemblyTitleAttribute("Goat.Utility.Merlin.Lib")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Généré par la classe MSBuild WriteCodeFragment.


//@FileName Goat.Utility.Merlin.Lib/obj/Debug/net8.0/Goat.Utility.Merlin.Lib.GlobalUsings.g.cs
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

//@FileName Goat.Utility.Merlin.Lib/obj/Release/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

//@FileName Goat.Utility.Merlin.Lib/obj/Release/net8.0/Goat.Utility.Merlin.Lib.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Goat.Utility.Merlin.Lib")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("Goat.Utility.Merlin.Lib")]
[assembly: System.Reflection.AssemblyTitleAttribute("Goat.Utility.Merlin.Lib")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Généré par la classe MSBuild WriteCodeFragment.


//@FileName Goat.Utility.Merlin.Lib/obj/Release/net8.0/Goat.Utility.Merlin.Lib.GlobalUsings.g.cs
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

//@FileName Merlin/obj/Debug/net8.0/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

//@FileName Merlin/obj/Debug/net8.0/Merlin.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     Ce code a été généré par un outil.
//     Version du runtime :4.0.30319.42000
//
//     Les modifications apportées à ce fichier peuvent provoquer un comportement incorrect et seront perdues si
//     le code est régénéré.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Merlin")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+29cf67bda211c0ce028e46335796ba2a4da7d199")]
[assembly: System.Reflection.AssemblyProductAttribute("Merlin")]
[assembly: System.Reflection.AssemblyTitleAttribute("Merlin")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Généré par la classe MSBuild WriteCodeFragment.


//@FileName Merlin/obj/Debug/net8.0/Merlin.GlobalUsings.g.cs
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

//@FileName Goat.Utility.Merlin.Lib/obj/Release/net8.0/win-x64/.NETCoreApp,Version=v8.0.AssemblyAttributes.cs
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

//@FileName Goat.Utility.Merlin.Lib/obj/Release/net8.0/win-x64/Goat.Utility.Merlin.Lib.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Goat.Utility.Merlin.Lib")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0")]
[assembly: System.Reflection.AssemblyProductAttribute("Goat.Utility.Merlin.Lib")]
[assembly: System.Reflection.AssemblyTitleAttribute("Goat.Utility.Merlin.Lib")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Généré par la classe MSBuild WriteCodeFragment.


//@FileName Goat.Utility.Merlin.Lib/obj/Release/net8.0/win-x64/Goat.Utility.Merlin.Lib.GlobalUsings.g.cs
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

